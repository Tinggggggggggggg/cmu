/**************************************************************************/
/*              COPYRIGHT Carnegie Mellon University 2023                 */
/* Do not post this file or any derivative on a public site or repository */
/**************************************************************************/
/*
 * Augment doubly linked lists with row and column information.
 *
 * 15-122 Principles of Imperative Computation */

/*** Interface ***/

typedef struct editor_header editor;
struct editor_header {
  tbuf* buffer;
  int row;
  int col;
};

bool is_editor(editor* E){
  return (E != NULL) && (is_tbuf(E->buffer)) && (E->col == tbuf_col(E->buffer))
         && (E->row == tbuf_row(E->buffer));
  // if (E == NULL){
  //   return false;
  // }
  // if (!is_tbuf(E->buffer)){
  //   return false;
  // }
  // if (E->col != tbuf_col(E->buffer) || E->row != tbuf_row(E->buffer)){
  //   return false;
  // }
  // return true;
}

editor* editor_new()
//@ensures is_editor(\result);
{
  editor* new = alloc(editor);
  new->buffer = tbuf_new();
  new->col = 0;
  new->row = 1;
  return new;
}                  /* Creates a new, empty text buffer */
void editor_forward(editor* E)
//@requires is_editor(E);
{
  if (tbuf_at_right(E->buffer)){
    return ;
  }
  if (E->buffer->cursor->data != '\n'){
    E->col += 1;
    tbuf_forward(E->buffer);
  } else {
    E->col = 0;
    E->row += 1;
    tbuf_forward(E->buffer);
  }
}        /* Moves the cursor forward (right) */
void editor_backward(editor* E)
//@requires is_editor(E);
{
  if (tbuf_at_left(E->buffer)){
    return ;
  }
  if (E->buffer->cursor->prev->data != '\n'){
    E->col --;
    tbuf_backward(E->buffer);
  } else {
    tbuf_backward(E->buffer);
    E->row --;
    E->col = tbuf_col(E->buffer);
    // tbuf_backward(E->buffer);
  }
}       /* Moves the cursor backward (left) */
void editor_insert(editor* E, char c)
//@requires is_editor(E);
{
  tbuf_insert(E->buffer,c);
  if (c != '\n'){
    E->col += 1;
  } else{
    E->row += 1;
    E->col = 0;
  }
} /* Insert a character before cursor */
void editor_delete(editor* E)
//@requires is_editor(E);
{
  if (tbuf_at_left(E->buffer)){
    return ;
  }
  if (E->buffer->cursor->prev->data != '\n'){
    E->col -= 1;
    tbuf_delete(E->buffer);
  } else{
    tbuf_delete(E->buffer);
    E->row -= 1;
    E->col = tbuf_col(E->buffer);
    // tbuf_delete(E->buffer);
  }
}         /* Remove character before cursor   */
void editor_up(editor* E);             /* Moves the cursor up              */
void editor_down(editor* E);           /* Moves the cursor down            */

/*** Implementation ***/




// Bonus: Implement these function if you do the bonus task
// void editor_up(editor* E) { }
// void editor_down(editor* E) { }
