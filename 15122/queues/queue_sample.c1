/**************************************************************************/
/*              COPYRIGHT Carnegie Mellon University 2022                 */
/* Do not post this file or any derivative on a public site or repository */
/**************************************************************************/
/*
 * Extended interface of queues
 *
 * 15-122 Principles of Imperative Computation
 */

#use <conio>
#use <util>


/************************************************************************/
/**************************** Client Interface **************************/

typedef void print_data_fn(void* x);            // may be useful for debugging
typedef bool check_property_fn(void* x);
typedef void* iterate_fn(void* accum, void* x);

/************************* End Client Interface *************************/
/************************************************************************/

/************************************************************************/
/************************* BEGIN IMPLEMENTATION *************************/

typedef struct list_node list;
struct list_node {
  void* data;
  list* next;
};

typedef struct queue_header queue;
struct queue_header {
  list* front;
  list* back;
  int size;
};

bool is_inclusive_segment(list* start, list* end, int i) {
  
  if(start==NULL){
    if(i!=0) return false;
    else return true;
  }
  if(start==end){
    if(start->next!=NULL||i!=1) return false;
    else return true;
  }
  if(i<0) return false;
  int length = 0;
  while(start!=NULL&&length<i){
    start=start->next;
    length++;
  } //start next !=null and length is 2
    //start = start next next length is 1

  if(length==i && start==NULL){return true;}
  //length==1  or start->next == NULL
  //should 
  //if length!=1 && start-> then return false
  //if length==1 && start->==NULL return true
                                //::::two need to fail at same time
  //else all false because cannot have length==1 and start not null
  //                or length!=1 start-> == NULL 
  //so no need for circularity
  return false;
}

bool is_queue(queue* Q) 
///@requires Q->size>=0; 
{
  return Q != NULL && is_inclusive_segment(Q->front,Q->back,Q->size);
}

void prt_int(void* x)
//@requires \hastag(int*,x);
{
  printf("%d",*(int*)x);
}

void print_queue(queue* Q, print_data_fn* print_data) 
//@requires is_queue(Q);
{
  if(Q->size<1) return;
  printf("\n%s:%d\n", "SIZE",Q->size);
  printf("%s:","START");
  (*print_data)(Q->front->data);
  printf("\n%s:","END");
  (*print_data)(Q->back->data);
  printf("\n");
  list* l = (*Q).front;
  while(l!=NULL){
    (*print_data)(l->data);
    l=l->next;
    printf("%s"," -> ");
  }
  printf("%s\n","NULL");
  return;
}

/* Other functions go there */


// Client type
typedef queue* queue_t;

/************************** END IMPLEMENTATION **************************/
/************************************************************************/

/************************************************************************/
/*************************** Library Interface **************************/

// typedef ______* queue_t;

queue_t queue_new()
/*@ensures \result != NULL&& is_queue(\result); @*/
{
  queue* q = alloc(queue);
  q->front=NULL; //dont care what end is
  q->size=0;
  return q;
}

int queue_size(queue_t Q)
  /*@requires Q != NULL&& is_queue(Q); @*/
  /*@ensures \result >= 0; @*/
{
  return Q->size;
}

void enq(queue_t Q, void* x)
  /*@requires Q != NULL&& is_queue(Q); @*/
  //@ensures Q->size>=0;
{
  //if 0 and call, front should be point to the only one
  //we cannot assume the start already have one item
  
  if(Q->size==0){
    Q->front=alloc(list);
    Q->back = Q->front;
    Q->front->data = x;
    Q->front->next = NULL;
    Q->size+=1;
    return;
  }
  list* l=alloc(list);
  l->data = x;
  l->next = NULL;
  Q->back->next = l;
  Q->back = l;
  
  Q->size+=1;
  return;//dummy
}

void* deq(queue_t Q)
  /*@requires Q != NULL && is_queue(Q) && queue_size(Q) > 0; @*/ 
{
  list* l = Q->front;
  Q->front = l->next;
  l->next = NULL;
  Q->size -= 1;
  return l->data;
}

/* O(i) -- doesn't remove the item from the queue */
void* queue_peek(queue_t Q, int i)
  /*@requires Q != NULL&& is_queue(Q) && 0 <= i && i < queue_size(Q); @*/
{
  list* l = Q->front;
  while(i>0){
    l = l->next;
    i--;
  }
  return l->data;
}

/* O(n) */
/*
//      a->b->c->d->NULL      
//NULL  a->b->c->d->NULL      
//NULL  a -> b -> c -> d ->NULL
    pr  ne
        cur

ne=ne->next;

//NULL  a -> b -> c -> d ->NULL
    pr       ne 
        cur

cur->next = pr

//NULL<- a   b -> c -> d ->NULL
    pr       ne 
        cur

pr=cur
cur=ne
//NULL<- a   b -> c -> d ->NULL
        pr  ne 
            cur

//NULL:
//NULL<- a <- b <- c <- d   NULL
                        pr  ne 
                            cur
*/
void queue_reverse(queue_t Q)
/*@requires Q != NULL&& is_queue(Q); @*/
{
    if(Q->size<2){
      return;
    }
    list* pr = NULL;
    list* ne = Q->front;
    list* cur = Q->front;
    Q->back = cur;
    int i = 0;
    while(ne!=NULL){
      printf("%d : %d\n",i,*(int*)cur->data);
      ne=ne->next; 
      cur->next = pr;
      pr=cur;
      cur=ne;
      i++;
    }
    Q->front=pr;
    
}

/* O(n) worst case, assuming P is O(1) */
bool queue_all(queue_t Q, check_property_fn* P)
  /*@requires Q != NULL && is_queue(Q)&& P != NULL; @*/
{
  //if(Q->size==0){return true;} 
  list* l = Q->front;
  while(l!=NULL){
    if(!((*P)(l->data))) return false;
    l=l->next;
    
  }
  return true;
}

/* O(n) worst case, assuming F is O(1) */
void* queue_iterate(queue_t Q, void* base, iterate_fn* F)
  /*@requires Q != NULL && is_queue(Q) && F != NULL; @*/
{
  //if(Q->size==0){return true;} 
  list* l = Q->front;
  void* a = base;
  while(l!=NULL){ 
    a = (*F)(a,(l->data));
    l=l->next;
  }
  return a;
}

